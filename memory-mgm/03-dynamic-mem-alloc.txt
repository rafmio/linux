Динамическая память возвращ-ся во время выполнения, а не во время компиляции.

Классический интерфейс Си для получения динамической памяти - malloc()

#include <stdlib.h>
void *malloc(size_t size);
При ошибке malloc() возвращ. NULL, a errno уст. ENOMEM. Выделенная память содержит мусор (не нули!)

Для malloc() существует обертка xmalloc(), кот. при ошибке выводит сообщение и завершает программу

Выделение массивов
#include <stdlib.h>
void *calloc(size_t nr, size_t size);
calloc() заполняет выделенную память нулями
При ошибке calloc() возвращает NULL, errno == ENOMEM

Выравнивание данных - способ располож.данных в пам. Большинство проц-ров оперируют машинными словами и могут обратиться к памяти, лишь если она выровнена по размеру слова.
Если переменная расположена в памяти по адресу, который кратен ее размеру, то она называется естественно выровненной.
Н-р, 32 битная переменная является естественно выровненной, если она расположена в памяти по адресу, кратному 4 - если два самых нижних бита этого адреса равны 0.

Выделение выровненной памяти.
POSIX предписывает malloc(), callo() и realloc() выравнивать правильно. В Linux эти ф-ции возвращают память, выровненную по 8-байтной границе в 32 системах и по 16-байтной границе в 64-битных.

Иногда нужно выделить дин.память по более широкой границе, например, по странице. Одна из причин - необходимость верно выровнять блоки, используемые при непосредственном блочном вводе-выводе или другом в-вии м/у аппаратными и программн.компонентами.
Для этой цели есть ф-ция posix_memalign()


valloc() - аналогична malloc(), но есть отличие - вся выделяем.память выравнивается по размеру страниц.
Применяемый в системе размер страницы можно получить с помощью getpagesize()

Правила выравнивания:
- при работе со стр-рой ее следует выравнивать по наибольш. из типов, входящ.в состав.
- суть не понял, но у gcc есть параметр -Wpadded, который как-то там выравнивает
- объединения: выравнивание происходит по самому крупному типу, входящему в объединение
- требование выравнивания массива: массив выравнивается по базовому типу. Т.е. массивы не предъявляют к выравниванию никаких требований, кроме предъявленных типами. В рез.происх. естественн.выравн.всех членов массива.


Текущее ограничение кучи называется крайней точной программы (program break).

Установка крайней точки программы: brk() и sbrk()
Изменение размеров кучи (т.е. выделение и высвобождение памяти) сводится лишь к тому, чтобы объяснить ядру, где располагается крайняя точка программы (program break).
Изначально крайняя точка прог-мы нах-ся сразу же за окончанием сегмента неиниц-х данных (&end).
После того, как эта точка будет сдвинута вверх, прог-ма сможет получать доступ к любому адресу во вновь выделенной памяти, но страницы физ.памяти пока выделяться не будут.

В программах brk() и sbrk() используются очень редко, но в работе разобраться стоит
brk() устанавливает крайнюю точку программы на место, указанное окончанием сегмента данных - end_data_segment. Т.к. вирт.память выделяется постранично, end_data_segment округляется до границы след.страницы. 
Попытка установить крайн.точку прог-мы ниже ее первонач.знач-я (т.е. ниже метки &end), скорее всего приведут к сбою.

sbrk() - надстройка над brk(), библиотечная ф-я. Приводит к изм.полож-я точки прог-мы утем инкрементирования. (intptr_r increment).
sbrk(0) - текущ.знач-е без изменения. Может пригодиться, если нужно отследить размер кучи.

В книге М.Керриска (M. Kerrisk) сравниваются brk() и sbrk() с malloc(), и говорится, что у них есть премущества. Как так? 
Разобраться использует ли malloc() под капотом brk().
Семейство malloc имеют преимущества перед brk - стандартизированы в Си, проще в нет.програм-х, вып.в неск.потоках, и проч.

Блок пам., возвращенный malloc(), всегда выравнивается по байтовой границе. 
