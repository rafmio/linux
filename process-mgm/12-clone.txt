#define _GNU_SOURCE
#include <sched.h>

int clone(int (*func) (void*), void *child_stack, int flags, void *func_arg, ...
			/* pid_t *ptid, struct user_desc *tls, pid_t *ctid */);
Возвращает:
- PID потомка
- -1 при ошибке:w

clone() - является переносимым. Следует избегать его применения в прикладных программах.

Новый процесс, создаваемый clone() - почти полная копия своего родителя, как и c fork()
Отличие - потомок не продолжает работу с момента вызова, а сначала вызывает ф-цию, указанную в аргументе func 
(будем называть ее "дочерней функцией").

Клонированный потомок может завершиться:
- при возврате из функции func. Возвращаемое значение - код завершения процесса
- при вызове exit() / _exit()

Родит.пр-цесс, как обычно, может ожидать завершения потомка с пом.wait() или аналогов

Клонированный потомок может разделять память с родителем
Клонированный потомок НЕ МОЖЕТ использовать родительский стек. Вместо этого он должен выделить для своего стека блок памяти
подходящ.размера и передать указатель на него в аргумент child_stack (child_stack должен указывать на верхний конец выделенного стека)

Аргумент flags - 2 цели:
	- его нижний байт содержит СИГНАЛ ЗАВЕРШЕНИЯ потомка, кот.передается родителю в момент заверш.доч.пр-са.
	  Если клонированный потомок останавливается по сигналу, родитель все равно получ. SIGCHLD 
	  Вызовы fork() и vfork() не позволяют выбрать сиг.заверш, это всегда будет SIGCHLD
	  Байт м.б. == 0, тогда сигнал не генерируется.
	- Оставшиеся байты отводятся под битовую маску, кот.определяет поведение clone(). 
	 	

Аргументы clone() - ptid, tls и ctid - относятся к реализации потока выполнения, в часности к использ. его идентификатора
и локальн. хранилища. 
