#define _GNU_SOURCE
#include <sched.h>

int clone(int (*func) (void*), void *child_stack, int flags, void *func_arg, ...
			/* pid_t *ptid, struct user_desc *tls, pid_t *ctid */);
Возвращает:
- PID потомка
- -1 при ошибке:w

clone() - является переносимым. Следует избегать его применения в прикладных программах.

Новый процесс, создаваемый clone() - почти полная копия своего родителя, как и c fork()
Отличие - потомок не продолжает работу с момента вызова, а сначала вызывает ф-цию, указанную в аргументе func 
(будем называть ее "дочерней функцией").

Клонированный потомок может завершиться:
- при возврате из функции func. Возвращаемое значение - код завершения процесса
- при вызове exit() / _exit()

Родит.пр-цесс, как обычно, может ожидать завершения потомка с пом.wait() или аналогов

Клонированный потомок может разделять память с родителем
Клонированный потомок НЕ МОЖЕТ использовать родительский стек. Вместо этого он должен выделить для своего стека блок памяти
подходящ.размера и передать указатель на него в аргумент child_stack (child_stack должен указывать на верхний конец выделенного стека)

Аргумент flags - 2 цели:
	- его нижний байт содержит СИГНАЛ ЗАВЕРШЕНИЯ потомка, кот.передается родителю в момент заверш.доч.пр-са.
	  Если клонированный потомок останавливается по сигналу, родитель все равно получ. SIGCHLD 
	  Вызовы fork() и vfork() не позволяют выбрать сиг.заверш, это всегда будет SIGCHLD
	  Байт м.б. == 0, тогда сигнал не генерируется.
	- Оставшиеся байты отводятся под битовую маску, кот.определяет поведение clone(). 
	 	

Аргументы clone() - ptid, tls и ctid - относятся к реализации потока выполнения, в часности к использ. его идентификатора
и локальн. хранилища. 

Единица планирования ядра (Kernel Scheduling Entity, KSE).
На самом деле потоки и процессы являются всего лишь экземплярами KSE

Если указать флан CLONE_FILES, родитель и потомок будут применять общую табицу дескрипторов. Результат выделения и утилизации
fd (вызовы open(), close(), dup(), pipe(), socket() и т.д.) в одном из пр-ссов будет доступен в другом.

Если флаг CLONE_FILES не указан, таблица fd не разделяется (мое: не шарятся?), а потомок в момент вызоова clone() получает копию родит.таблицы.

Если указать флаг CLONE_FS, родитель и потомок будут использ. общую инфу, связ-ю с файловой системой: umask, корневой и тек.каталог.
Если флаг CLONE_FS не указан - родитель и потомок получают отдельные копии этой инфы

CLONE_SIGHAND - родитель и потомок исп.общую таблицу действий сигналов. Применение sigaction() или signal() для изменения действия
сигнала в одном из пр-сов, отразится на другом. Если CLONE_SIGHAND не установлен - потомок получает копию родит.таблицы
Начиная с Linux 2.6 при использ. CLONE_SIGHAND нужно указывать флаг CLONE_VM

CLONE_VM - род. и потомок будут использовать общие страницы вирт.памяти. Вносимые изменения будут касаться обоих процессов.
Если CLONE_VM не установлен - потомок получает копию вирт.памяти пр-сса

Если указать CLONE_TRHEAD - потомок будет помещен в одну группу потоков с родителем.
В противном случае потомок помещается в новую группу, выделенную спец-но для него.

getid() - позволяет получить потоку свой собст. TID (это то же значение, что возвращ. поток, кот. вызывает clone() )
Ядро гарантирует, что TID не совпадет с ID любого процесса (кроме случаев, когда поток в группе является лидирующим для пр-сса)
Первый поток в новой группе имеет тот же ID, что и сама группа. Такой поток называют лидирующим.

Когда поток с флагом CLONE_THREAD завершает работу, поток, кот.создал его с пом. clone(), не получает никакого сигнала.
Соответственно wait() не подходит для ожидания потоков, созданных таким способом. 
Вместо этого - pthread_join()
Для определения того, что поток, созданный с использ-ем флага CLONE_TREADS завершил работу, применяется спец. средство 
синхронизации, которое называется ФЬЮТЕКС


