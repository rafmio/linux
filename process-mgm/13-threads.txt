Поток выполнения - механизм для одновременного выполнения неск.параллелльн задач в рамках одного приложения.
Создание дочерних процессов с пом. fork() приводит к ограничениям:
	- т.к. родитель и потомок не разделяют память (помимо RO текстового сегмента), мы вынуждены использ.
	  некую форму межпроцессн.в-вия для обмена данными
	- создание пр-сса с пом. fork() потребляет относит-но много ресурсов (даже при copy-on-write):
	  приходится дублировать атрибуты пр-са - таблицы со стр-цами памяти, файл.дескр-ми - тратится время

Потоки помогают избавл.от этих проблем:
	- обмен быстр и прост, нужно только скопир. данные в общие переменные (глоб. или в куче)
	  Но тут приходится применять методы синхронизации
	- созд. потока заним. меньше времени, чем созд. пр-сса - минимум десятикратный выигрыш в произв-сти
	  Многие атрибуты вместо копирования шарятся.

errno
В традиционном интерфейсе UNIX переменная errno является глобальной и целочисленной.
Но! Если поток вызвал ф-цию, записавшую ошибку в глоб.переменную errno, это может ввести в заблуж-е другие потоки,
кот.вызываю ф-ции и проверяют errno. Т.е. результатом будет состояние гонки.
Т.о. в многопоточных программах каждый поток имеет свой отдельный экземпляр errno. Для этого errno  объявляется в виде макроса,
кот.разворачивается в вызов ф-ции, возвращающий измеяемое значение вида lvalue, уникальное для кажд.потока

Значение, возращаемое ф-циями в Pthreads
Традиционно вызовы и некот ф-ции:
- возвращ. 0 при успехе
- возвращ. -1 при ошибке
- для обознач.самой ошибки применяется переменная errno

Ф-ции в программном интерфейсе Pthreads ведут себя иначе:
- возвращ. 0 при успехе
- при ошибке использ-ся положительное значение - одно из тех значений, кот.можно присвоить переменной errno в
  традицион. сис.вызовах UNIX

pthread_t *thread;
int s;

s = pthread_create(&thread, NULL, func, &arg);
if (s != 0) {
	perror(s, "pthread_create");
}

КОМПИЛЯЦИЯ
В Linux программы, кот.использ. программный интерфейс Pthreads, должны компилироваться с параметром cc -pthread.
Среди действий этого параметра можно выделить:
	- обявляется макрос препроцессора _REENTRANT. Это открывает доступ к объявлениям неск-х реентерабельных 
	  (повторно входимых) фукнций
	- программа компонуется с библиотекой libpthread (эквивалент параметра -lpthread)


СОЗДАНИЕ ПРОТОКОВ
Сразу после запуска итоговый процесс состоит из одного потока, который называют главным или исходным.

#inlcude <pthread.h>

int pthread_create(
pthread_t *thread,
const pthread_attr_t *attr,
void *(*start)(void *),
void *arg
);

Новый поток начинает выполнение с вызова ф-ции в виде значения start и принимающий аргумент arg (т.е. start(arg))
