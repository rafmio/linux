fork() - не принимает аргументы
Вызов fork() часто имеет смысл делать без послед.вызова exec()
Ключевым моментом в понимании fork() является то, что после завершения его работы мы получаем 2 процесса, каждый из которых продолжает выполнение с момента возврата их вызова.
Оба пр-са выполняют один и тот же програмный код, но обладают разн.копиями сегментов стека, данных и кучи.
Сегменты потомка вначале полностью дублируют соотв.части своего родителя. Но после завершения fork() кажд. из процессов может самостоятельно изменять переменные в своих сегментах, не влияя на др.процесс.

pit_t fork() - возвращает PID дочернего процесса, либо -1 в случае ошибки.

После выполнения fork() потомок получает копии всех fd родителя. Эти копии создаются в той же манере, как работает ф-ция dup();
это означает, что соот-щие fd в родит. и дочерн. пр-сах указывают на один и тот же открытый файл.
Дескриптор открыт.файла содержит его текущ.смещение (образовавшееся в рез-те редактир-я с пом. read(), write() и lseek()) и флаги состояния (установленные open() и измененные операцией fcntl() F_SETFL).
	Как следствие, эти атрибуты откр.файла явл. общими для родителя и потомка. Н-р, если дочерний процесс обновляет смещение, это изменение доступно его родителю посредством соотв. дескр-ра.
	
	Любые ожидающие сигналы прерываются и не наследуются дочерним процессом
	Никакие блокировки файлов не наследуются дочерним процессом
	После fork() оба процесса выполняют тот же программный код, но обладают разными копиями сегментов стека, данных и кучи.	
	Чаще всего fork() используется для создания нового процесса и последующей загрузки в него нового двоичного образа.

Иногда fork() используют так:

pid_t childPid;

switch ( childPid = fork() ) {
	case -1:
		/* Обработка ошибки */
	case 0:
		/* Работа с потомком */
	default:
		/* Выполнение действий, связанных с родителем */
}


После вызова fork() невозможно сказать какой из 2х процессов первым получит от планировщика ресурсы ЦП. В плохо написанных программах это может привести к состоянию гонки.

Дескриптор открытого файла содержит его текущее смещение и флаги состояния. Эти атрибуты являются общими для родителя и потомка. Если дочерний процесс обновляет смещение, это изменение доступно его родителю.

В принципе fork() - создание копий родительского сегментов с текстом, данными, кучей и стеком. Однако обычное копирование страниц виртуальной памяти - расточительство. Во избежание такого избыточного копирования применяют 2 методики:
	- ядро делает текст.сегмент кажд.процесса read only, чтобы они не смогли изменить свой код. Это значит, что род.		и потомок могут иметь общий текст.сегмент. fork() создает текстовый сегмент потомка путем построения записей
	  в таблице страниц памяти для кажд. отдельн. пр-сса. Кажд. запись ссылается на блок страниц физич.памяти,
	  кот. уже исп-ся родителем 
	- для страниц род-ского пр-сса в сегментах с данными, кучей и стеком ядро использует методику copy-on-write.
	  Ядро подготавливает

 
