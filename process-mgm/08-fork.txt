fork() - не принимает аргументы
Вызов fork() часто имеет смысл делать без послед.вызова exec()
Ключевым моментом в понимании fork() является то, что после завершения его работы мы получаем 2 процесса, каждый из которых продолжает выполнение с момента возврата их вызова.
Оба пр-са выполняют один и тот же програмный код, но обладают разн.копиями сегментов стека, данных и кучи.
Сегменты потомка вначале полностью дублируют соотв.части своего родителя. Но после завершения fork() кажд. из процессов может самостоятельно изменять переменные в своих сегментах, не влияя на др.процесс.

pit_t fork() - возвращает PID дочернего процесса, либо -1 в случае ошибки.

После выполнения fork() потомок получает копии всех fd родителя. Эти копии создаются в той же манере, как работает ф-ция dup();
это означает, что соот-щие fd в родит. и дочерн. пр-сах указывают на один и тот же открытый файл.
Дескриптор открыт.файла содержит его текущ.смещение (образовавшееся в рез-те редактир-я с пом. read(), write() и lseek()) и флаги состояния (установленные open() и измененные операцией fcntl() F_SETFL).
	Как следствие, эти атрибуты откр.файла явл. общими для родителя и потомка. Н-р, если дочерний процесс обновляет смещение, это изменение доступно его родителю посредством соотв. дескр-ра.
	
	Любые ожидающие сигналы прерываются и не наследуются дочерним процессом
	Никакие блокировки файлов не наследуются дочерним процессом
	
	Чаще всего fork() используется для создания нового процесса и последующей загрузки в него нового двоичного образа.
