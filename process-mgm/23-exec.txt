В случае успешного выполнения exec() предыдущий процесс исчезает, а его место занимает новый. Т.е. не происходит создание нового процесса. Если выполняется инструкция, которая идет после exec(), то это означает, что exec() закончилась с ошибкой.

При вызове fork() создается новый процесс, при exec() - нет.

fork() дублирует все содержимое памяти род.пр-сса, потомку доступны все те же адреса и переменные.
exec() уничтожает структуру памяти базового процесса и создаёт новую стр-ру, основанную на загруженном исп-мом файле. 

exec() не копирует атрибуты, ничего не наследует

Исполняемыми являются объектные файлы ELF, Mach, или скрипты, которым нужен интерпретатор. Когда польз. прост-во инициирует exec(), ядро получает новый запрос на запуск исполняем. файла. Оно пытается найти подходящий обработчик для файлов этого типа и затем использует ЗАГРУЗЧИК, чтобы загрузить содержимое исп.файла.

Со скриптом загруж-ся интерпретатор, кот.обычно указ-ся в первой строчке скрипта символом #!

Действия загрузчика:
- проверить контекст выполнения и права доступа поль-ля, кот. запросил выполнение
- выделить для нов.пр-сса адресн. пр-во в осн.памяти
- скопировать двоич. содержимое исп.файла в выделенное пр-ство. В основном сегменты данных и кода
- выделить память под стек и подготовить начальные привязки памяти
- создать главн.поток выпол-я и его сегмент стека
- скопировать аргументы командной строки в стековый фрейм и поместить его на вершину стека главного потока
- инициализировать регистры, необходимые для выполнения
- выполнить первую инструкцию точки входа в программу

Методы разделения ресурсов
Методы разделения состояния между процессами либо размещаютс в каком-то "месте", достпуном ряду процессов, либо отправляется (передается) в виде сообщения или события, либо извлекаются откуда-то. Для отправки требуется хранилище (или носитель) в виде буфера памяти или файловой системы, для умения извлечь применяется механизм обмена сообщениями или канал между процессами. 

Пример первого - массив в разделяемой области памяти, кот. м.б. прочитан и изменен, пример второго - комп.сеть, служащая каналом для передачи сообщений м/у процессами.

Первый метод - активный, т.к. процесс, кот.хочет прочитать сообщение, должен извлечь его из хранилища
Второй метод - пассивный, т.к. тем, кому нужен канал для передачи состояяния, не нужно извлекать данные из носителя

Активные методики считаются устаревшими. Популярным становится пассивный подход. 

Активные методики:
- разделяемая память
- файловая система
- сетевые сервисы - сетевые хранилища или сервисы хранения и извлечения разделяемого состояния. 


РАЗДЕЛЯЕМАЯ ПАМЯТЬ 
Разделяемая память - самый быстрый способ обмена данными между поцессами, без использования системных вызовов ядра.
Сегмент разделяемой памяти подключается в свободную часть виртуального адресного прост-ва пр-сса.
После создания разделяемого сегмента памяти любой из польз. пр-ссов может присоединить его к своему вирт.прос-ву и работать с ним как с обычным сегментом памяти. 
Недостаток - отсутствие средств синхронизации. Но это решаемо с помощью семафоров. 

Динамические библиотеки обычно загружаются в память один раз и отображены на несколько процессов, кроме некоторых специфичных для отдельного процессов 

Реализация POSIX:
- shm_open - создание или подключение объекта разделяемой памяти POSIX по его имени
- shm_unlink - удаление объекта разделяемой памяти по его имени
- ftruncate - задает или изменяет размер разделяемой памяти (или отображенного в память файла)
- mmap - подключает существующий или создает анонимный сегмент разделяемой памяти к адр. прост-ву пр-сса

МОЕ: насколько я понял файл объекта памяти, созданный shm_open() хранится в /dev/shm

Работа с разделяемой памятью:
- создать объект разеляемой памяти с пом. shm_open(). Можно будет посмотреть в /dev/shm
- изменить его размер с пом. ftruncate()
- ??? сделать объект видимым с помощью mmap()? 

Объект разделяемой памяти существует, пока его использует хотя бы один процесс. Но удаление произойдет при перезагрузке, процессам придется создавать их заново, если потребуется


