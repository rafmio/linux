exec - семейство
execl - аргументы передаются списком (l)
execv - аргументы передаются массивом (v)

p - система будет искать указанный файл по полному пользовательскому пути. Можно указать только имя файла, если он находится в пределах пользовательского пути
execlp
execvp

e - означает, что для нового процесса создается новое окружение
execle
execve

В случае успешного выполнения execl() изменяет не только адресное пространство и образ процесса, но и:
- любые ожидающие сигналы исчезают
- любые сигналы, отлавливаемые процессом, возвращаются к своему поведению по умолчанию, поскольку обработчиков сигналов больше нет в процессном адрестном пространстве
- все блокировки памяти удаляются
- большинство атрибутов потока возвращаются к значениям по умолчанию
- большая часть статистических данных процесса не сбрасывается
- все адресное пространство памяти, относящееся к данному процессу, включая загруженные файлы, очищаются
- все, находящиеся исключ-но в польз.прост-ве, включая функц-сти библиотеки Си, например поведение atexit(), удалаяется

НЕ изменяются некоторые свойства, н-р PID, приоритет, польз-ль и группа - остаются такими же

Обычно при работе семейства exec() наследуются и открытые файлы. Но это нежелательно. Обычная практика - закрытие файлов перед запуском exec, но можно отдать команду ядру делать это автоматически через fcntl()


#include <unistd.h>
int execve(const char *pathname, char *const argv[], char *const envp[]);

Ничего не возвращает при успехе
Возвращает -1 при ошибке

Аргумент pathname - путь к новой программе, которая должна быть загружена в память процесса.
argv - параметны командной строки. argv[0] - имя команды, обычно совпадает с названием исп.файла (последней части pathname).
envp - список переменнх среды. Соответствует массиву environ новой программы. Это список указателей, ссылающихся на 
символьные строки NAME=VALUE, кот.завершается NULL. 

/proc/<PID>/exe - символьная ссылка, содержит абсолютный путь к исполняемому файлу, запущенному соотв.пр-ссом

После вызова execve() PID не меняется, т.к. сам процесс продолжает существовать.
В случае успеха execve() заменяет собой вызвавшую его прог-му.

Не нужно проверять результат выполнения execve(), т.к. факт того, что execve() что-то вернул - уже свидет.об ошибке.

МОЕ: насколько я понял есть единственный syscall execve(), а все остальное семейство - библиотечные функции: execl(), execv(),
execle(), и проч

Керриск, рекоммендация: программы с установленным ID пользователя или группы никогда не должны применять функцию system() - 
функцию по исполнению консольных команд.

Ключ -с команды sh позволяет выполнить произвольные консольные команды, записанные в строку.
Реализация system() с пом. execl():
execl("/bin/sh", "sh", "-c", command, (char*) NULL);


