fork()
exit()
wait()
execve()

exit(status) - библиотечная ф-ция, обертка вокруг системного вызова _exit().
Обычно с пом. exit() завершают работу одного родителя или потомка, порожденного fork(). Остальные пр-сы нужно завершать с пом. _exit()

Сист.вызов wait(&status) - имеет 2 значения:
	- если работа потомка тек.пр-са еще не была завершена с пом. exit(), 
	  то ф-я wait() приостанавл. выпол-е родителя, пока не будет завершен один из его потомков.
	- код заверш-я потомка возвр-ся через аргумент ф-ции wait()

fork() - не принимает аргументы
Вызов fork() часто имеет смысл делать без послед.вызова exec()
Ключевым моментом в понимании fork() является то, что после завершения его работы мы получаем 2 процесса, каждый из которых продолжает выполнение с момента возврата их вызова.
Оба пр-са выполняют один и тот же програмный код, но обладают разн.копиями сегментов стека, данных и кучи.
Сегменты потомка вначале полностью дублируют соотв.части своего родителя. Но после завершения fork() кажд. из процессов может самостоятельно изменять переменные в своих сегментах, не влияя на др.процесс.

pit_t fork() - возвращает PID дочернего процесса, либо -1 в случае ошибки.

После выполнения fork() потомок получает копии всех fd родителя. Эти копии создаются в той же манере, как работает ф-ция dup();
это означает, что соот-щие fd в родит. и дочерн. пр-сах указывают на один и тот же открытый файл.
Дескриптор открыт.файла содержит его текущ.смещение (образовавшееся в рез-те редактир-я с пом. read(), write() и lseek()) и флаги состояния (установленные open() и измененные операцией fcntl() F_SETFL).
	Как следствие, эти атрибуты откр.файла явл. общими для родителя и потомка. Н-р, если дочерний процесс обновляет смещение, это изменение доступно его родителю посредством соотв. дескр-ра.

!!!Дошел до темы совмес. доступа к файлу родителя и потомка. Появилась необходимость вспомнить read(), write() и lseek().
Керриск - Стр. 536 
