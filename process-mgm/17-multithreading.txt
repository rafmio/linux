Конкурентность можно реализовать в виде:
1 - многопоточности
2 - многопроцессности

ПОТОКИ
Инициатор и владелец любого потока - процесс. Невозможно создать разделяемый поток и передать владением им другому пр-ссу.
У каждого процесса - минимум 1 поток - главный или основной.

Все потоки имеют общий PID. Кажд. поток наследует все его атрибуты, в т.ч. ID группы, пользовател, текущ. рабоч. каталог и 
обработч. сигналов.

У каждого потока есть уникальный TID (thread ID). 
У каждого потока есть собственная выделенная маска сигналов, позволяющая фильтровать сигналы, кот. он будет получать.

Когда процесс принудительно завершается, вместе с ним удаляются все его потоки.
Когда заканчивает работу главный поток, процесс немедленно завершается. Но если у него есть другие отсоединенные потоки, 
то он подождет, пока все он не доработают до конца.

Программу, в которой потоки синхронизированы и больше не наблюдается гонка данных ли состояния гонки
называется ПОТОКОБЕЗОПАСНОЙ.

Native POSIX Threading Library, NPTL - главная реализация pthreads для Linux. Достаточно подключить <pthread.h>
У этой библиотеки есть расширения, доступные только при подключении <semaphore.h>

Создав поток с помощью pthread_create() мы его присоединяем (pthread_join()). Каждый процесс изначально имеет всего один
главный поток, родителем которого выступает пр-сс-владелец. Сам этот поток играет роль родителя всех остальных потоков.
Обычно этот пр-сс завершается вместе с главным потоком, а вслед за ним немедленно прекращают рабту все другие "спящие" потоки.

Т.о. если новый поток еще на начал выполняться (т.к. еще не получил доступа к пр-ссору), а родительский поток завершился
(не важно по какой причине), он будет удален еще до выполнения своей первой инструкции. Поэтому главный поток
должен присоединить второй поток, чтобы подождать, пока тот не завершит работу. 
	Главный поток блокируется с пом. pthread_join().

	Поток становится завершенным, только после возвращении ф-ции компаньона (? всегда ли?). После завершения ф-ции-компаньона
главный поток освобождается и получает возможность продолжить работу, что приводит к завершению программы.

	Поток мало создать. Он должен упеть получить доступ к ядру процессора.
	Поток, который можно присоединить, называют соединяемым (joinable). Все потоки таковы по умолчанию. Отсоединенные 
потоки невозможно присоединить. 

ОТСОЕДИНЕННОЕ СОСТОЯНИЕ - один и атрибутов потока, кот. можно установить перед его созданием и кот.позволяет его отсоединить.
Можно отсоединить и с помощью pthread_detach().

Note: ф-ция printf() является потокобезопасной, выводит символы всегда в нужном порядке.

Два потока не могут инициировать один и тот же вызов ф-ции - каждому вызову необх.создать стековый фрейм, кот. д.б. помещен
на вершину стека какого-то опр-нного потока, а два разных потока имеют два разных сегмента стека.

Указатель, который передается потоку, не д.б. высячим, иначе могут возникнуть серьёзные проблемы с памятью.
Висячий указатель ссылается на адрес в памяти, по которому не выделена переменная (т.е. этот участок уже освобождён). 

	Для выявления висячих указателей необходимо использовать ПРОФИЛИРОВЩИК ПАМЯТИ, например valgrind.  

	NOTE: операции инкрементирования - не атомарны, могут испытовать варианты чeредований
	
	Избавиться от гонки данных можно с помощью управляющ. мех-змов, таких как семафор, мьютекс
