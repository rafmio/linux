Управление буферизацией
При стандартном вводе-выводе (stdin, stdout, stderr) реализуется три типа пользовательской буферизации.
	- без буферизации 		 - польз.буферизация не применяется. Данные отправляются прямо в ядро. Использ-ся редко.
							   По умол-ю без буферизации работает работает stderr

	- построчная буферизация - на каждом символе перехоад на новую строку содержимое буфера отправляется в ядро
							   Буферизация строк целесообразна при работе с потоками данных, чей вывод
							   попадает на экран. Построчная буферизация по умолч-ю исп-ся с потоками данных, 
							   подключ-х к терминалам, например stdout

	- поблочная буферизация  - буферизация выполняется поблочно. В данном случае блок - это фикс. кол-во байтов.
							   По умолч-ю поблочная буф-ция применяется со всеми потоками данных, кот. ассоциированы
							   с файлами. В контексте std I/O поблочная буф-ция назыв-ся полной буф-цией


Буферизация в std I/O:

#include <stdio.h>
int setvbuf(FILE *stream, char *buf, int mode ,size_t size);
							   

При работе с файлами на диске read() и write() не инициируют непосредственный доступ к диску. Вместо этого они копируют данные между:
	- буфером в пространстве памяти пользователя и
	- буфером в буферном кэше ядра (после ядра 2.4 - страничная кэш-память)

write(fd, "abc", 3);  // - переносит 3 байта данных из буфера в прос-тве памяти польз-ля в буф. в прост-ве ядра

После этого происходит возвращение из syscall write(), чуть поздже ядро записывает (сбрасывает) свой буфер на диск.
Говорят, что "системный вызов НЕ СИНХРОНИЗИРОВАН с дисковой операцией).
Если в данном промежутке времени какой-нибудь другой пр-цесс попытается читать эти байты файла, ядро автоматически предоставит данные из буферной кэш-памяти, а не из файла (с устаревшим содержимым).

Аналогично для ввода ядро считывает данные с диска и сохр. их в буфере ядра. Вызовы read() извлекают данные из этого буфера, пока он не будет исчерпан, после чего ядро считывает след.фрагмент файла в буферную кэш-память. 

Благодаря этому read() и write() не приходится находиться в режиме ожидания долгих дисковых операций.

С версии ядра 2.4 больше не создается отдельная буферная кэш-память. Вместо этого буферы файлового I/O включаются в страничную кэш-память. В ядрах серии 2.2 и ранее было 2 отдельных кэша - страничный и буферный. В первом кэшировались страницы, в втором - буферы. В версии 2.4 оба кэша объединили вместа,сейчас один дисковый кэш - страничный 
