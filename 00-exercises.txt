last stop book: 536
last stop exercises: file-io/chunck/23-ReadFile.go

1. код на си - PID, PPID
2. код на Go - PID, PPID
3. ls /proc, htop, ps, ps -eaf, cat /proc/<PID>/cmdline, cat /proc/<PID>/status
4. strace ./executableFile;
   использовать ключ -k: $ strace -l sleep 1 # ключ -k выдает стек вызовов
5. $ lsof -p <PID> # просмотр открытых файлов процесса
6. $ systemctl # просмотр запущенных процессов
7. $ ps | grep -v "\?" # вывести результаты, кроме тех, что содержит "?". Обратный слэш \ - экранирование
8. Перевести процесс в фон (Ctrl+Z), просмотр процессов в фоне jobs, jobs -l, переключение на процесс в фоне fg %1 (дошло: fg - ForeGround)
9. Убить процесс жестко: $ kill -KILL <pid>, убить процесс корректно $ kill -TERM <pid>
10. Просмотр дампа файла $ objdump -d <fileName>
11. Просмотр ассемблерный код исп.файла на Си $ gcc -S <fileName> 
12. Написать код по запуску execve() на Си, в т.ч. с аргументами
13. Просмотр размеров текстового сегмента бинарника: $ size -A fileName.exe
14. код на Си - размещение переменных в сегментах памяти процесса
15. код на Си - адрес вершины стека процесса
16. cat /proc/<PID>/maps, pmap <PID>
17. Поупражняться с brk(), поискать динамику сдвигов крайней точки программы
18. Заглянуть в потоки процессов: /proc/PID/task/TID # TID - Thread ID
19. Утилита ip: $ ip -br a
20. Утилита ping: $ ping -c 10 www.google.com # -c 10 - количество пингов
21. Разобраться с ForkExec() в Go - найти примеры использования и корректного завершения процессов
22. По аналогии с 05-execve.c написать бинарник, который будет делать export PATH=$PATH:/usr/local/go/bin
23. Просмотр каталога /proc/PID/fdinfo - открытых для процесса дескрипторов файлов
24. Написать код, в котором будут:
	- open(), openat()
	- close()
	- read()
	- write()
	- lseek()
	- stat() / fstat() / lstat()
	- mkdir(), rmdir()


